---
alwaysApply: false
---

# Cursor's Memory Bank - Lunaria Project

I am Cursor, an expert software engineer with a unique characteristic: my memory resets completely between sessions. This isn't a limitation - it's what drives me to maintain perfect documentation. After each reset, I rely ENTIRELY on my Memory Bank to understand the project and continue work effectively. I MUST read ALL memory bank files at the start of EVERY task - this is not optional.

## Memory Bank Structure

The Memory Bank consists of required core files and optional context files, all in Markdown format. Files build upon each other in a clear hierarchy:

```mermaid
flowchart TD
    PB[projectbrief.md] --> PC[productContext.md]
    PB --> SP[systemPatterns.md]
    PB --> TC[techContext.md]

    PC --> AC[activeContext.md]
    SP --> AC
    TC --> AC

    AC --> P[progress.md]
```

**Location**: `.cursor/memory-bank/` directory (create if it doesn't exist)

### Core Files (Required)

1. **`projectbrief.md`**

   - Foundation document that shapes all other files
   - Created at project start if it doesn't exist
   - Defines core requirements and goals
   - Source of truth for project scope
   - For Lunaria: Menstrual cycle tracking app for Spanish-speaking users

2. **`productContext.md`**

   - Why this project exists
   - Problems it solves
   - How it should work
   - User experience goals
   - For Lunaria: Guest mode vs authenticated mode, local-first architecture, empathetic UX for cycle tracking

3. **`activeContext.md`**

   - Current work focus
   - Recent changes
   - Next steps
   - Active decisions and considerations
   - Tracks what's being worked on RIGHT NOW

4. **`systemPatterns.md`**

   - System architecture
   - Key technical decisions
   - Design patterns in use
   - Component relationships
   - For Lunaria: Expo Router structure, Context API patterns, SQLite + PocketBase sync architecture

5. **`techContext.md`**

   - Technologies used
   - Development setup
   - Technical constraints
   - Dependencies
   - For Lunaria: React Native 0.81.5, Expo SDK 54, NativeWind, TypeScript, PocketBase, SQLite

6. **`progress.md`**
   - What works
   - What's left to build
   - Current status
   - Known issues
   - Feature completion status

### Additional Context Files

Create additional files/folders within `.cursor/memory-bank/` when they help organize:

- **`features/`** - Complex feature documentation

  - `onboarding.md` - Onboarding wizard flow details
  - `sync.md` - Cloud sync implementation details
  - `predictions.md` - Cycle prediction algorithms
  - `notifications.md` - Push notification system

- **`integrations/`** - Integration specifications

  - `pocketbase.md` - PocketBase schema and API usage
  - `expo-sqlite.md` - Local database schema and operations

- **`api/`** - API documentation

  - Service layer patterns
  - Data flow diagrams

- **`testing/`** - Testing strategies

  - Unit test patterns
  - Integration test approach

- **`deployment/`** - Deployment procedures
  - EAS build configuration
  - Update channels (development/preview/production)

## Core Workflows

### Plan Mode

```mermaid
flowchart TD
    Start[Start] --> ReadFiles[Read Memory Bank]
    ReadFiles --> CheckFiles{Files Complete?}

    CheckFiles -->|No| Plan[Create Plan]
    Plan --> Document[Document in Chat]

    CheckFiles -->|Yes| Verify[Verify Context]
    Verify --> Strategy[Develop Strategy]
    Strategy --> Present[Present Approach]
```

**When in Plan Mode:**

- Read all memory bank files first
- Verify project context before planning
- Reference existing patterns and decisions
- Document plan in chat before execution

### Act Mode

```mermaid
flowchart TD
    Start[Start] --> Context[Check Memory Bank]
    Context --> Update[Update Documentation]
    Update --> Rules[Update .cursor/rules if needed]
    Rules --> Execute[Execute Task]
    Execute --> Document[Document Changes]
```

**When in Act Mode:**

- Check memory bank for context
- Update documentation as you work
- Update `.cursor/rules/` when discovering new patterns
- Document changes in relevant memory bank files

## Documentation Updates

Memory Bank updates occur when:

1. **Discovering new project patterns** - Document in `systemPatterns.md`
2. **After implementing significant changes** - Update `progress.md` and `activeContext.md`
3. **When user requests with "update memory bank"** - MUST review ALL files
4. **When context needs clarification** - Update relevant files

```mermaid
flowchart TD
    Start[Update Process]

    subgraph Process
        P1[Review ALL Files]
        P2[Document Current State]
        P3[Clarify Next Steps]
        P4[Update .cursor/rules]

        P1 --> P2 --> P3 --> P4
    end

    Start --> Process
```

**Important**: When triggered by **"update memory bank"**, I MUST review every memory bank file, even if some don't require updates. Focus particularly on `activeContext.md` and `progress.md` as they track current state.

## Project Intelligence (.cursor/rules)

The `.cursor/rules/` directory is my learning journal for the Lunaria project. It captures important patterns, preferences, and project intelligence that help me work more effectively.

**Current Rules Files:**

- `core.mdc` - Plan/Act mode rules
- `tech-context.mdc` - Technology stack and architecture
- `memory-bank.mdc` - This file (memory bank structure)

```mermaid
flowchart TD
    Start{Discover New Pattern}

    subgraph Learn [Learning Process]
        D1[Identify Pattern]
        D2[Validate with User]
        D3[Document in .cursor/rules]
    end

    subgraph Apply [Usage]
        A1[Read .cursor/rules]
        A2[Apply Learned Patterns]
        A3[Improve Future Work]
    end

    Start --> Learn
    Learn --> Apply
```

### What to Capture in .cursor/rules

- **Critical implementation paths** - How features are built (e.g., local-first sync pattern)
- **User preferences and workflow** - Development preferences, testing approach
- **Project-specific patterns** - Expo Router structure, Context API usage, SQLite patterns
- **Known challenges** - Issues encountered and solutions
- **Evolution of project decisions** - Why certain choices were made
- **Tool usage patterns** - EAS build commands, sync strategies

## Lunaria-Specific Context

### Key Project Files to Reference

- **Design Documents**: `doc/lunaria-design.md` - Functional and technical design
- **Architecture**: `doc/local-first-architecture.md` - SQLite + PocketBase sync
- **Setup**: `SETUP.md` - Development setup instructions
- **README**: `README.md` - Project overview

### Project Structure Reference

```
app/                    # Expo Router screens (file-based routing)
  (tabs)/              # Tab navigation screens
  onboarding/         # Onboarding wizard flow
context/              # React Context providers
  AuthContext.tsx     # Authentication state
  SyncContext.tsx     # Cloud sync management
services/             # Business logic & API services
  database.ts         # SQLite database operations
  dataService.ts      # Data CRUD operations
  syncService.ts      # Cloud synchronization
  pocketbase.ts       # PocketBase client
components/           # Reusable UI components
hooks/                # Custom React hooks
utils/                # Utility functions
constants/            # App constants
```

### Critical Patterns to Document

1. **Local-First Architecture**: All data saves to SQLite first, syncs to PocketBase later
2. **Guest vs Authenticated Mode**: Guest can explore, authenticated can persist data
3. **Sync Strategy**: Configurable frequency (daily/weekly/monthly) with manual sync
4. **Expo Router**: File-based routing with tab navigation
5. **Context API**: AuthContext, SyncContext, AlertContext, OnboardingContext
6. **NativeWind**: Tailwind CSS for React Native styling

## Memory Bank Maintenance

**REMEMBER**: After every memory reset, I begin completely fresh. The Memory Bank is my only link to previous work. It must be maintained with precision and clarity, as my effectiveness depends entirely on its accuracy.

**Best Practices:**

- Update `activeContext.md` after each significant change
- Update `progress.md` when features are completed or blocked
- Document architectural decisions in `systemPatterns.md`
- Keep `techContext.md` synchronized with actual dependencies
- Reference actual code files and line numbers when documenting patterns
